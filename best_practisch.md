Best-in-Class React Native Stack for Social Platforms (2024-2025)
TanStack Query + Zustand + FlashList + React Navigation 7 + TypeScript strict mode + Reanimated 3 form the production-ready foundation used by Shopify, Discord, and thousands of social apps. This comprehensive guide delivers battle-tested architectural patterns, caching strategies, and performance optimizations specifically for social platforms like Meet5 with real-time updates, location discovery, messaging, and event management.
What makes a social platform different
Social apps face unique challenges: real-time data synchronization across thousands of users, infinite-scroll feeds with rich media, optimistic updates for likes and comments, offline-first messaging, and complex navigation flows. Your stack must handle these gracefully while maintaining 60 FPS scrolling and sub-2-second app startup. React Native 0.76+ with the New Architecture (Fabric + TurboModules) now delivers 30-40% faster startup and 50% less memory usage compared to legacy architecture. DEV Community +7 Combined with FlashList's 10x performance improvement over FlatList, the modern React Native ecosystem finally matches native performance expectations. DEV Community +5 Major companies like Shopify (300+ screens, 95% code sharing) and Discord (migrating fully to RN in 2024) have proven these patterns work at massive scale. Shopify Engineering +2 The key is choosing complementary libraries that work together seamlessly rather than fighting each other.
State management: Server state plus client state
Use TanStack Query v5 for all server state and Zustand for client state. This separation is the industry standard for 2024-2025, replacing the older all-Redux approach. TanStack Query (formerly React Query) handles fetching, caching, synchronization, and background updates for data from your API, TanStack while Zustand manages UI state like theme preferences, bottom sheet visibility, and form state. Together they're only 16KB but provide exceptional developer experience.
TanStack Query v5 (5.90.8 as of November 2024) npm brings automatic caching with configurable staleness, built-in optimistic updates via the onMutate hook, suspense support that's now stable, and useMutationState for tracking concurrent mutations. The bundle size dropped 20% from v4 while adding new features. TanStack For social platforms, configure staleTime and gcTime (formerly cacheTime) based on data freshness needs: user profiles can stay fresh for 10 minutes since they change infrequently, feed posts need 1-minute staleness for that real-time feel, comments should refresh every 30 seconds, but messages need staleTime of 0 to always fetch fresh data. The queryClient configuration looks like this: create a new QueryClient with defaultOptions for queries setting appropriate staleTime, gcTime, retry count of 2, and enabling refetchOnWindowFocus and refetchOnReconnect for mobile app backgrounding scenarios. TanStack
RTK Query only makes sense if you're already deeply invested in Redux Toolkit. While it provides similar server state management, it requires the entire Redux setup (adding 25KB), lacks native infinite query support, and requires more boilerplate for optimistic updates. The React Native community has largely moved to TanStack Query for its simplicity and smaller bundle size.
Zustand (4.x, only 3KB) handles client state with minimal boilerplate. No providers needed—just create a store with your state and actions, optionally add persistence middleware to save to MMKV storage, and you're done. Better StackDEV Community The pattern is straightforward: import create from zustand and persist from zustand/middleware, then create your store with state properties and setter functions. Better Stack For example, an app store might track theme (light/dark), userId, and authentication status. Use Zustand for navigation state, UI toggles, form state, preferences, and anything that doesn't come from the server.
Jotai (2.x, also 3KB) offers an atomic state approach that automatically optimizes re-renders through fine-grained subscriptions. Fe-tool It shines for complex forms with interdependent fields or scenarios requiring automatic dependency tracking. Better StackOpenReplay The choice between Zustand and Jotai: Zustand uses a single store model with manual optimization (you control what causes re-renders), while Jotai uses atomic state with automatic optimization (components only re-render when their specific atoms change). GitHubDEV Community For most social apps, Zustand's imperative API is more intuitive, but Jotai excels when you need complex interdependent state without manual memoization. OpenReplay
Redux Toolkit remains relevant for enterprise teams with 100+ developers needing strict architectural patterns, time-travel debugging, and complex state orchestration across many features. DEV Community If you're starting fresh and not in enterprise, skip Redux—the ecosystem has moved on.
Caching strategies for social apps
Optimistic updates are non-negotiable for social apps. When users like a post, join an event, or send a message, the UI must respond instantly. TanStack Query provides two patterns: the simple UI variables approach where you check mutation.isPending in your component and render the optimistic state with reduced opacity, and the full cache manipulation approach where you use onMutate to snapshot current data, update the cache optimistically, then onError to roll back if the server rejects the change, and onSettled to invalidate and refetch. tanstack
For likes, comments, and event joins, use the full cache manipulation pattern. In your mutation configuration, onMutate should first cancel any ongoing queries for that data, snapshot the previous state for potential rollback, then use queryClient.setQueryData to update the cache immediately. tanstack Map over your posts array and increment likeCount or toggle liked boolean for the relevant post. Return the previous snapshot from onMutate. If the mutation fails, onError receives that snapshot as context and restores it with setQueryData. Finally, onSettled invalidates the query to refetch the truth from the server. tanstack This pattern gives zero perceived latency for user actions while maintaining data consistency.
For concurrent updates (multiple users liking the same post simultaneously), use useMutationState to track pending mutations. This new TanStack Query v5 hook filters mutations by key and status, returning an array of pending operations. tanstack Display these as "in-flight" indicators in your UI to show the user that their action is processing even if others' actions complete first.
Offline-first architecture requires a mutation queue. Use @react-native-community/netinfo to detect offline status, then queue mutations to MMKV storage when offline. When the user goes back online, process the queue and sync pending actions. The pattern: create a useOfflineMutation hook that wraps useMutation, checks if offline, and if so, stores the mutation data to a queue in MMKV and throws an error (preventing TanStack Query from trying the request), but still applies optimistic updates so the UI feels responsive. When connectivity returns, a useSyncQueue hook processes queued mutations one by one.
Cache invalidation strategies depend on your data relationships. For mutation-based invalidation, onSuccess handlers call queryClient.invalidateQueries with relevant query keys—when you post a comment, invalidate both the post's comments and the user's comment count. For real-time updates via WebSockets, message handlers call queryClient.setQueryData to update specific entities or invalidateQueries to refetch affected lists. Time-based invalidation with refetchInterval works for location data or activity feeds that should refresh every 30 seconds regardless of user interaction.
Persistence: MMKV beats everything
react-native-mmkv v4 is 30x faster than AsyncStorage and essential for production apps. MMKV uses JSI (JavaScript Interface) for synchronous C++ operations, eliminating the async/await overhead of AsyncStorage. Benchmarks on iPhone 11 Pro show 1000 operations take 26ms with MMKV versus 520ms with AsyncStorage. Medium It includes encryption support, uses only 50KB on Android and 30KB on iOS, and provides a simple synchronous API. MediumGitHub
Integration with TanStack Query requires createSyncStoragePersister from @tanstack/query-sync-storage-persister. Create a persister with storage methods that map to MMKV's getString, set, and delete, then pass it to persistQueryClient with your queryClient and a maxAge of 24 hours. This persists your query cache to disk, enabling instant app startup with cached data while background refetches update stale content.
WatermelonDB offers complex relational data storage built on SQLite, providing lazy loading and reactive observables. It maintains sub-1ms query performance even with 10,000+ records. ClarionTech Use WatermelonDB for offline-first messaging apps or social networks with complex graph relationships where you need SQL-like queries. For your Meet5-style platform, combine MMKV for simple persistence (auth tokens, preferences, query cache metadata) with WatermelonDB if implementing offline-first event browsing or messaging that needs to store thousands of messages with relationships.
AsyncStorage is deprecated—migrate everything to MMKV. The migration is straightforward since MMKV provides a compatible API.
Architecture patterns for scale
Feature-based folder structure scales better than layer-based organization. Instead of grouping all components together, all hooks together, organize by feature (authentication, feed, messaging, profile, events). Waldo Each feature folder contains its own components, hooks, services, types, and screens. This co-location improves developer productivity (find everything related to a feature in one place), enables better code ownership (teams own features not layers), and reduces merge conflicts (features rarely touch the same files).
The Ignite boilerplate from Infinite Red (12,200+ GitHub stars, 9+ years of production use) provides a battle-tested structure. GitHubInfinite Ignite 11 ships with Expo SDK 53, React Native 0.76+ with New Architecture enabled by default, TypeScript strict mode, and built-in generators for screens and components. The structure places all app code in an app directory with subdirectories for components, screens, navigators, services, theme, utils, i18n, config, and devtools. Infiniteinfinite Assets live separately. This pattern has proven itself in hundreds of client projects. GitHub
For Expo Router projects using file-based routing, the structure shifts to an app directory with (tabs) for tab navigation groups, _layout.tsx for layouts, dynamic routes with [id].tsx syntax, and route groups with (auth) for organization without affecting URLs. VyomscodeExpo Documentation Components, lib, api, and types folders support the screens.
Clean Architecture applies to React Native through three layers: domain (business logic, entities, use cases, repository interfaces—platform agnostic), infrastructure (API implementations, database access, repository implementations—framework specific), and presentation (UI components, screens, hooks—React Native specific). GitHub The dependency rule ensures inner layers never depend on outer layers—domain never imports from infrastructure or presentation. Medium This separation enables testability (test business logic without UI), reusability (share domain layer between platforms), and maintainability (change API clients without touching business logic).
Component composition patterns improve reusability. Compound components like Tabs with Tabs.List and Tabs.Tab children provide flexible APIs through context. Custom hooks like useFetchData encapsulate data fetching logic for reuse across screens. Alex Kondov Render props enable sharing behavior while giving consumers control over rendering. For social platforms, build compound components for complex UI patterns like post cards with PostCard.Header, PostCard.Content, PostCard.Actions.
TypeScript strict mode is mandatory for 2024-2025. Morrow Enable all strict flags: strict, strictNullChecks, strictFunctionTypes, strictBindCallApply, strictPropertyInitialization, noImplicitAny, noImplicitThis, noImplicitReturns, noFallthroughCasesInSwitch, noUncheckedIndexedAccess, noUnusedLocals, and noUnusedParameters. React Native Configure path aliases with baseUrl set to dot and paths mapping @/ to src/, @components/ to src/components/, and similarly for screens, hooks, services, types, utils, and assets. Medium +2 These aliases require configuration in three places: tsconfig.json for TypeScript, babel.config.js using babel-plugin-module-resolver for Metro bundler, and metro.config.js to recognize the resolution. React NativeNegative Epsilon
Type-safe navigation prevents entire classes of bugs. Define a RootStackParamList type with all screen names as keys and their param types as values. Screens without params use undefined. React NavigationNetlify Declare this globally by extending ReactNavigation.RootParamList with your type, enabling automatic type inference in useNavigation hooks throughout your app. Netlify Create a custom useAppNavigation hook that returns useNavigation with proper typing, then navigation.navigate calls have full autocomplete for screen names and params.
Monorepo considerations: use Turborepo or Nx if sharing code between React Native mobile and React web, building multiple related apps (consumer and merchant apps), sharing a design system or component library, or working with teams of 5+ developers. Skip monorepos for single app projects, small teams under 5 developers, projects without code sharing requirements, or when you need simpler deployment. Turborepo offers lower complexity and faster setup, Nx provides more features but steeper learning curve, and pnpm workspaces give manual control without tooling overhead. For monorepos, configure Metro to watch the workspace root and resolve node_modules from both project and workspace levels. DEV Community
Real-time data and API integration
WebSockets via Socket.IO provide the most reliable real-time experience for social features. For event updates (someone joins your activity), chat message delivery, typing indicators, read receipts, and presence systems (who's online), WebSockets give bidirectional communication with automatic reconnection and fallback transports. Ably Integrate WebSocket events with TanStack Query by calling queryClient.setQueryData when messages arrive to update specific entities or queryClient.invalidateQueries to refetch affected lists.
Firebase Firestore offers real-time listeners with built-in offline support and excellent mobile SDKs. Expo Documentation Listeners automatically sync changes, making it ideal for real-time activity feeds and event updates. InvertaseDEV Community Supabase Realtime provides similar functionality built on Postgres changes via logical replication, supporting database changes, broadcast channels for peer-to-peer messaging, and presence tracking. Expo Documentation Both eliminate the need to manage WebSocket servers yourself.
For API layer architecture, REST APIs with OpenAPI/Swagger schemas work well for most social apps. Generate TypeScript types from OpenAPI schemas using openapi-typescript or similar tools for end-to-end type safety. MediumLogRocket GraphQL with Apollo Client provides normalized caching (automatically updates all references when you fetch a user) and fragments for composable queries, reducing over-fetching. The GuildDEV Community tRPC offers end-to-end TypeScript type safety without code generation for projects where you control both frontend and backend—types are inferred directly from your API router. Robin Wieruch React Native compatibility exists but requires polyfills for fetch.
TanStack Query integrates seamlessly with any HTTP client. For REST, use axios or fetch with query and mutation functions that return promises. For GraphQL, Apollo Client hooks can coexist with TanStack Query (Apollo for queries with normalized caching, TanStack Query for everything else) or use graphql-request with TanStack Query for simpler GraphQL without Apollo's complexity. For tRPC, @trpc/react-query provides hooks that work identically to TanStack Query but with full type inference.
Connection state management is critical for mobile. Listen to NetInfo events to detect online/offline transitions, pause queries when offline (TanStack Query has a networkMode option), resume with retry when connectivity returns, and implement exponential backoff for reconnection attempts. WebSocket libraries should automatically reconnect but verify your implementation handles backgrounding (iOS suspends connections when apps background) and foreground (reestablish connections when returning to app).
Navigation: React Navigation 7 is production-ready
React Navigation v7 (released November 2024) brings static API, screen preloading, and enhanced type safety. Viewlytics The static API simplifies configuration—define screens and their options in createNativeStackNavigator, pass to createStaticNavigation, and TypeScript types are automatically generated. No more manual type declarations. Screen preloading with navigation.preload improves perceived performance by loading destination screens before navigation completes. reactnavigation +2 This matters for image-heavy profile screens or complex event details.
Deep linking setup requires defining a linking configuration with prefixes (myapp:// and https://myapp.com) and screen paths. LogRocket React Navigation matches URLs to screens automatically. Expo DocumentationExpo Documentation For social platforms, implement paths for feed, profile/:userId, event/:eventId, chat/:conversationId so users can share activities via links that open directly in-app. LogRocket
Expo Router v3 provides file-based routing (Next.js style) with automatic deep linking, universal app support (shared navigation between mobile and web), bundle splitting for web, API routes in beta for building backend endpoints, and static generation for landing pages. Infinite +2 It's built on React Navigation but abstracts configuration into file structure. Viewlytics Team +3 Choose Expo Router if building universal apps (web and mobile) or wanting file-based routing's simplicity. Choose React Navigation 7 if building mobile-first or preferring explicit configuration. Attract GroupManglesh's Blog
React Native Navigation from Wix offers true native navigation using UIViewController on iOS and FragmentActivity on Android, providing native animations and better performance for very complex apps. Bits KingdomGitHub The tradeoff is steeper learning curve, more complex setup, and imperative API. LogRocket For most social apps, React Navigation 7's performance is sufficient and the DX is far superior. Stack Overflow +2
Type-safe routing patterns: declare a global module augmentation for ReactNavigation extending RootParamList with your stack params, create custom hooks that return properly typed useNavigation results, and enjoy full autocomplete for navigation.navigate calls. React Navigation This prevents typos in screen names and incorrect params at compile time.
Performance optimization: FlashList and New Architecture
FlashList v2 delivers 10x performance improvement over FlatList and is mandatory for feeds. Shopify's benchmarks on Moto G10 (low-end Android) show FlatList achieves 9.28 FPS on JS thread with frequent blank cells, while FlashList maintains 41.56 FPS with zero blank cells. Thewidlarzgroup +3 Version 2 removes the need for estimatedItemSize (automatic layout calculation), adds masonry layout support for Pinterest-style grids, requires New Architecture (Fabric), and provides accurate scrollToIndex. Shopify EngineeringGitHub
Migration from FlatList to FlashList is nearly drop-in: import FlashList from @shopify/flash-list instead of FlatList from react-native, remove keyExtractor if using default id field, and that's it. GitHub For feeds with multiple item types (posts, ads, stories), provide getItemType to help FlashList optimize recycling. Shopify The performance improvement is immediately noticeable on lower-end devices.
React Native's New Architecture (Fabric renderer + TurboModules + JSI) is production-ready and enabled by default in React Native 0.76+. React Native Fabric provides synchronous UI updates without the bridge, concurrent rendering support for React 18, and better layout performance with Yoga v3. TurboModules offer lazy loading (modules initialize on-demand), direct JS-to-native calls via JSI eliminating JSON serialization, and type-safe interfaces via CodeGen. Shopify Engineering +3 Performance gains include 30-40% faster startup time, 50% reduction in memory usage, and near-zero frame drops in animations. DEV Community +4 Enable with newArchEnabled=true in android/gradle.properties and fabric_enabled: true in ios/Podfile. React Native
Expo Image replaces React Native Fast Image as the recommended solution for 2024-2025. Built-in disk and memory caching uses native libraries (SDWebImage on iOS, Coil on Android), blurhash placeholders provide smooth loading states, automatic WebP support reduces bandwidth, and priority loading optimizes above-the-fold content. LogRocket +2 The recyclingKey prop is crucial when using Expo Image inside FlashList—it helps the list recycle images correctly during scrolling. Preload critical images like user avatars with Image.prefetch for instant display. Stack Overflow Clear cache when needed with clearDiskCache and clearMemoryCache methods.
React Native Reanimated 3 enables 60-120 FPS animations by running on the UI thread via worklets (JS code that runs on UI thread). DRC Systems Seamless gesture integration with react-native-gesture-handler supports complex interactions like pull-to-refresh, swipeable actions, and bottom sheets. DEV Community +3 Always animate non-layout properties (transform, opacity) for best performance. Limit simultaneous animations (Android handles 100, iOS handles 500) Swmansion and profile with Reanimated devtools.
Hermes engine is default since React Native 0.70 and provides 50% faster startup through ahead-of-time compilation, 30% smaller binary size, 40% less memory usage, and optimized garbage collection. FB +6 Verify with global.HermesInternal check. Bytecode compilation happens automatically during release builds. FB
For infinite scroll feeds, combine FlashList with useInfiniteQuery from TanStack Query. The pattern: useInfiniteQuery fetches pages with pageParam, getNextPageParam extracts the next cursor from responses, maxPages limits memory usage (new in v5), and flatten data.pages for FlashList. Implement onEndReached to trigger fetchNextPage when users scroll near bottom, use onEndReachedThreshold of 0.5 for optimal UX (trigger halfway through last item), and show loading spinner in ListFooterComponent during fetches. Xmartlabs
Memoization prevents unnecessary re-renders. Wrap components with React.memo and provide custom comparison functions (only re-render if specific props changed). Use useCallback for all callbacks passed to child components, useMemo for expensive computations, Stack Overflow and React.lazy with Suspense for code splitting heavy screens. Bacancy TechnologyReact Native For post cards in feeds, memo with ID comparison prevents re-renders when unrelated posts update.
Testing strategies for confidence
Jest with React Native Testing Library forms the foundation, with Maestro for E2E testing. React Native Testing Library (v12+) follows the principle "test how users interact, not implementation details." GitHubnpm Query priority: getByText and getByLabelText for user-visible content, getByPlaceholderText for form inputs, getByRole for accessibility-first testing, and getByTestID only as last resort. GitHub Test user behavior—press buttons, type text, verify results—not internal state. reactnative
Mock Service Worker v2 (MSW) provides network-level mocking that intercepts actual HTTP requests. Unlike mocking axios directly, MSW works with any HTTP client (fetch, axios, ky), reuses handlers across testing, development, and Storybook, and makes no assumptions about implementation. Callstack Setup requires fast-text-encoding and react-native-url-polyfill for React Native compatibility. Mock Service Worker Define handlers with http.get, http.post using HttpResponse.json for responses, create server with setupServer CallstackMedium from msw/native (not msw/node for React Native), Mock Service Worker and start/stop in beforeAll/afterAll hooks.
Testing custom hooks uses renderHook from @testing-library/react-native. Wrap state updates in act() to ensure React processes updates. Onspace Test complex reusable hooks this way, but test simple hooks through component integration tests instead.
Maestro (recommended for 2024-2025) provides YAML-based E2E tests with zero native code changes, cross-platform support, Maestro Studio GUI for recording tests, and faster setup than Detox. Hybrid HeroesDRC Systems Detox offers deep React Native integration with automatic synchronization and Jest integration but requires complex setup and native code changes. Medium +2 Choose Maestro for most projects due to superior developer experience and simpler maintenance. MediumMedium
Testing navigation flows requires wrapping components in NavigationContainer during tests. Testing real-time features uses jest-websocket-mock to simulate WebSocket servers. Testing offline behavior mocks @react-native-community/netinfo to return isConnected: false.
Target 80% code coverage with 75% branch coverage. Focus on critical paths (authentication, posting, payments) achieving 90-100% coverage. DEV Community Use no-large-snapshots ESLint rule to limit snapshot tests to small stable components only.
Developer experience with Claude Code
Create a comprehensive CLAUDE.md file at project root documenting your entire tech stack, folder structure, coding conventions, testing guidelines, and architecture decisions. This file serves as permanent context for Claude, dramatically improving code generation quality. Apidog Include project overview with tech stack versions, project structure with explanations of each directory, npm scripts documentation, code style and conventions (functional components, TypeScript strict, ESLint rules, naming conventions, file patterns), testing guidelines (use RNTL, test behavior not implementation, 80% coverage minimum, mock APIs with MSW), and architecture notes (feature-based structure, state management patterns, API client patterns). Apidog
Type definitions improve AI suggestions. Well-typed interfaces for User, Post, Event, Message enable Claude to generate correct code. JSDoc comments on complex functions provide context. Discriminated unions for state machines help Claude understand valid state transitions.
Use descriptive file naming: PascalCase for components (UserProfile.tsx), camelCase for hooks with use prefix (useAuth.ts), camelCase for utilities (formatDate.ts), PascalCase for interfaces (User, ApiResponse), and ComponentName.test.tsx for tests. Consistent patterns help Claude navigate codebases.
Additional Claude Code best practices: use /clear command between unrelated tasks to reset context, ask Claude to plan before implementation for better architecture, use @filename syntax to reference specific files, define custom commands in .claude/commands/ directory for repeated tasks, leverage TDD-first prompts (describe test cases first, then ask for implementation), version control the .claude folder for team sharing, update memory with # shortcut during sessions, and set up MCP servers for extended capabilities. MediumAnthropic
ESLint and Prettier configuration is mandatory. Install @typescript-eslint/eslint-plugin, @typescript-eslint/parser, eslint-plugin-react-native, eslint-plugin-react-hooks, and eslint-config-prettier. Headway +4 Configure extends array with @react-native preset, TypeScript recommended rules, React hooks rules, and prettier last. Enable react-native/no-inline-styles warning and react-hooks/rules-of-hooks error. DEV Community +2
Husky with lint-staged automates pre-commit checks. Configure lint-staged in package.json to run eslint --fix, prettier --write, and jest --findRelatedTests on staged files. DEV CommunityMedium Add npm run type-check to pre-commit hook. This prevents committing broken code.
Reactotron is the recommended debugger for 2024-2025 over Flipper. It works without debug mode (no performance hit), provides Redux state inspection, network monitoring, custom commands, timeline view, and clipboard integration. Thewidlarzgroup +2 Configure in dev environment only with conditional import.
API design patterns
REST APIs with OpenAPI/Swagger schemas enable type generation. Use openapi-typescript to generate TypeScript types from your OpenAPI spec, achieving end-to-end type safety without manual type maintenance. LogRocket Implement proper versioning (v1, v2 in URL path), request/response interceptors for auth token injection, retry logic with exponential backoff for transient failures, and request deduplication to prevent duplicate requests.
GraphQL with Apollo Client provides normalized caching where fetching a user once updates all references automatically. Fragments enable composable queries—define PostFragment with common fields, include in multiple queries, reducing over-fetching. The Guild +3 Apollo DevTools integrates with Flipper for query inspection. For simpler GraphQL without Apollo overhead, use graphql-request with TanStack Query for queries and mutations while maintaining familiar React Query patterns.
tRPC offers end-to-end TypeScript type safety without code generation. Define your API router in the backend with t.procedure.query and t.procedure.mutation, export the router type, and frontend hooks automatically infer types. Robin Wieruch This eliminates the OpenAPI generation step entirely. Robin Wieruch React Native support requires polyfills (react-native-url-polyfill) and works best when you control both frontend and backend codebases.
Recommended stack for Meet5-style platform
For social activities platform with event management, real-time updates, location-based discovery, messaging, profiles, and payments, use this production-ready stack:
Core: React Native 0.76+, Expo SDK 53+, TypeScript 5.3+ strict mode, Hermes engine (default)
State Management: TanStack Query v5 (5.90.8) for server state, Zustand (4.x) for client state, MMKV (4.x) for persistence
Navigation: React Navigation 7.x with static API and type-safe routing, or Expo Router 3.x if building universal app with web presence
Lists & Images: FlashList 2.x (mandatory for feeds, requires New Architecture), Expo Image 1.10+ (replaces Fast Image)
Animations: Reanimated 3.x with react-native-gesture-handler 2.14+ for 60 FPS UI-thread animations
Real-time: Socket.IO for WebSockets, or Firebase/Supabase Realtime for managed real-time with offline support
API Layer: REST with OpenAPI type generation, or GraphQL with Apollo Client for normalized caching, or tRPC for end-to-end type safety
Location: react-native-maps with clustering (use-supercluster) for performance with many markers
Testing: Jest 29.7+, React Native Testing Library 12.4+, MSW 2.0+ for API mocking, Maestro for E2E
Development: ESLint + Prettier + Husky + lint-staged, Reactotron for debugging, EAS Build for CI/CD
Monitoring: Sentry for crash reporting and performance monitoring, Analytics (Segment/Mixpanel/Amplitude)
This stack provides 95% code sharing between iOS and Android, achieves 60 FPS scrolling in feeds, supports offline-first with optimistic updates, enables real-time event updates and messaging, Sendbird scales to hundreds of screens (proven by Shopify), maintains sub-2-second cold start times (with New Architecture + Hermes), and delivers exceptional developer experience for AI-assisted development with Claude Code.
Start with Ignite CLI (npx ignite-cli@latest new MyApp) for best-practice structure, or create-expo-app with TypeScript template for Expo Router approach. Infinite Enable New Architecture immediately (default in RN 0.76+), configure path aliases and strict TypeScript, set up TanStack Query with MMKV persistence, implement FlashList for all lists from day one, integrate Expo Image for all remote images, configure Reactotron for debugging, set up ESLint, Prettier, and Husky, create comprehensive CLAUDE.md file, write tests alongside features (not after), and implement feature flags for gradual rollouts.
The React Native ecosystem has matured dramatically in 2024-2025. Performance now matches native expectations, developer experience rivals web development with hot reload and TypeScript, and production apps handle millions of users reliably. This stack represents battle-tested patterns from Shopify processing billions of requests, Discord serving millions of concurrent users, and hundreds of successful social platforms. Shopify Engineering +2 All recommendations use current stable releases proven in production, not experimental libraries or bleeding-edge versions.
Library versions (November 2024): react-native 0.76.x, @tanstack/react-query 5.90.8, zustand 4.x, react-native-mmkv 4.x, @react-navigation/native 7.0.0, expo-router 3.x, @shopify/flash-list 2.x, react-native-reanimated 3.x, expo-image 1.10+, @testing-library/react-native 12.4.0, msw 2.0.0, reactotron-react-native 5.1.0, typescript 5.3+, expo SDK 53+
